# Combined Python File
# This file is autogenerated by combine_python_files function

# ----- Begin _integ.py (Encoding: ascii) -----
import argparse
from pathlib import Path
import chardet # type: ignore
 

def detect_encoding(file_path, num_bytes=10000):
    """
    Detects the encoding of a file using chardet.

    Parameters:
    - file_path (Path): Path to the file.
    - num_bytes (int): Number of bytes to read for detection.

    Returns:
    - str: Detected encoding or 'utf-8' as default.
    """
    with file_path.open('rb') as f:
        rawdata = f.read(num_bytes)
    result = chardet.detect(rawdata)
    encoding = result['encoding']
    if not encoding:
        encoding = 'utf-8'
    return encoding

def combine_python_files(source_dir, output_file):
    """
    Combines all Python (.py) files in the specified directory and its immediate first-level subdirectories
    into a single Python file, excluding the output file itself.

    Parameters:
    - source_dir (str or Path): The directory containing Python files to combine.
    - output_file (str or Path): The path to the output Python file.

    Raises:
    - FileNotFoundError: If the source directory does not exist.
    - IOError: If there are issues reading or writing files.
    """
    source_path = Path(source_dir).resolve()
    output_path = Path(output_file).resolve()

    if not source_path.is_dir():
        raise FileNotFoundError(f"The directory {source_dir} does not exist.")

    # Initialize a set to store Python files
    python_files = set()

    # Add .py files from the top-level source directory
    top_level_files = sorted(source_path.glob("*.py"))
    python_files.update(top_level_files)

    # Add .py files from immediate first-level subdirectories
    first_level_dirs = [d for d in source_path.iterdir() if d.is_dir()]
    for sub_dir in first_level_dirs:
        sub_dir_py_files = sorted(sub_dir.glob("*.py"))
        python_files.update(sub_dir_py_files)

    # Convert the set to a sorted list
    python_files = sorted(python_files)

    # Exclude the output file itself if it's within the source directory or its first-level subdirectories
    python_files = [py_file for py_file in python_files if py_file.resolve() != output_path]

    if not python_files:
        print(f"No Python files found in directory and its immediate subdirectories: {source_dir}")
        return

    try:
        with output_path.open('w', encoding='utf-8') as outfile:
            outfile.write("# Combined Python File\n")
            outfile.write("# This file is autogenerated by combine_python_files function\n\n")
            
            for py_file in python_files:
                # Detect file encoding
                encoding = detect_encoding(py_file)
                
                # Compute the relative path for better readability in comments
                relative_path = py_file.relative_to(source_path)
                outfile.write(f"# ----- Begin {relative_path} (Encoding: {encoding}) -----\n")
                
                with py_file.open('r', encoding=encoding, errors='replace') as infile:
                    contents = infile.read()
                    outfile.write(contents)
                    outfile.write("\n\n")
                
                outfile.write(f"# ----- End {relative_path} -----\n\n")
        
        print(f"Successfully combined {len(python_files)} files into {output_file}")
    
    except IOError as e:
        print(f"An error occurred while reading or writing files: {e}")

def main():
    """
    Main function to parse command-line arguments and invoke the combine function.
    """
    parser = argparse.ArgumentParser(
        description="Combine all Python (.py) files in a directory and its immediate first-level subdirectories into a single Python file."
    )
    parser.add_argument(
        "source_dir",
        type=str,
        help="Path to the source directory containing Python files."
    )
    parser.add_argument(
        "output_file",
        nargs='?',
        default="combined.py",
        help="Path to the output Python file. Defaults to 'combined.py' in the current directory."
    )
    
    args = parser.parse_args()

    combine_python_files(args.source_dir, args.output_file)

if __name__ == "__main__":
    main()


# ----- End _integ.py -----

# ----- Begin agents/query_generator.py (Encoding: ascii) -----
# agents/query_generator.py

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain.chains import LLMChain
from dotenv import load_dotenv
import os
import logging
from rich.console import Console

console = Console()
load_dotenv()

# Initialize the logger
logger = logging.getLogger(__name__)

# Initialize the OpenAI LLM with LangChain
llm = ChatOpenAI(temperature=0.0,model_name="gpt-4o-mini")

def generate_pandas_query(question, schema):
    logger.info("Generating pandas query.")

    prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                """
                You are a data analyst. Based on the following schema and question, generate an efficient pandas query.
                Return only the pandas query code without any explanations. You should return the code not human-like text.
                The code should not have any comments.
                You should not put any code in triple backticks.
                The query result should be store in a variable named 'query_result'
                For example: 
                    query_result = df[["column1", "column2"]]
                Schema:
                {schema}

                Pandas Query:
                """,
            ),
            ("human", "{question}"),
        ]
    )
    chain = prompt | llm 
    _input = {"schema": schema, "question": question}
    response = chain.invoke(_input)


    # Extract the query code from the response
    code = response.content.strip()
    console.log(f"Generated code: {code}")

    # Sanitize and validate the code if necessary
    # if 'query' in code:
    #     try:
    #         exec_globals = {}
    #         exec(code, {}, exec_globals)
    #         pandas_query = exec_globals.get("query", "")
    #     except Exception as e:
    #         logger.error(f"Error executing generated code: {e}")
    #         pandas_query = ""
    # else:
    #     pandas_query = code  # Assuming the code itself is the query string

    pandas_query = code
    logger.info(f"Generated pandas query: {pandas_query}")
    return pandas_query


# ----- End agents/query_generator.py -----

# ----- Begin agents/response_generator.py (Encoding: ascii) -----
# agents/response_generator.py

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv
import os
import logging
from rich.console import Console

console = Console()
load_dotenv()

# Initialize the logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
# Initialize the OpenAI LLM with LangChain
llm = ChatOpenAI(temperature=0.5, model_name="gpt-4o-mini")

def generate_final_response(question, query_result, summary):
    logger.info("Generating final response.")
    prompt = ChatPromptTemplate.from_messages(
        [
        (
            "system",
            """
            You are an AI assistant. Given the user's question, the query result, and a summary of the dataset, provide a concise and helpful answer.
                Query Result:
                {query_result}

                Dataset Summary:
                {summary}

                Answer:
            """,
        ),
        ("human", "{question}"),
        ]
    )


    chain = prompt | llm 
    _input = {
        "question": question,
        "query_result": query_result.to_string(index=False),
        "summary": summary
    }
    response = chain.invoke(_input)

    logger.debug(f"LLM response: {response.content}")

    final_response = response.content
    logger.info("Final response generated.")
    return final_response


# ----- End agents/response_generator.py -----

# ----- Begin agents/visualizer.py (Encoding: ascii) -----
# agents/visualizer.py

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv
import os
import matplotlib.pyplot as plt
import logging
from rich.console import Console

console = Console()
load_dotenv()

# Initialize the logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
# Initialize the OpenAI LLM with LangChain
llm = ChatOpenAI(temperature=0.0, model_name="gpt-4o-mini")

def generate_matplotlib_code(question, schema):
    logger.info("Generating matplotlib code.")
    prompt = ChatPromptTemplate.from_messages(
        [
        (
            "system",
            """
            You are a data visualization expert. Based on the following schema and question, generate matplotlib code to visualize the data appropriately.
            Provide only the code between triple backticks. the user passed the dataframe as df variable, you should not read the csv the df is input.

            Schema:
            {schema}

            ```python
            # Matplotlib code here
            ```
            """,
        ),
        ("human", "{question}"),
        ]
    )

    chain = prompt | llm 
    _input = {"schema": schema, "question": question}
    
    response = chain.invoke(_input)

    logger.debug(f"LLM response: {response.content}")

    # Extract code between ```python and ```
    code = extract_code_block(response.content)

    logger.debug(f"Extracted code: {code}")

    return code.strip()

def extract_code_block(response):
    import re
    code_match = re.search(r'```python(.*?)```', response, re.DOTALL)
    if code_match:
        code = code_match.group(1)
    else:
        code = response
    return code

def save_plot(code, df):
    logger.info("Saving plot.")
    # Prepare a namespace for exec
    namespace = {'df': df, 'plt': plt}
    try:
        exec(code, namespace)
        plot_filename = 'plot.png'
        plt.savefig(plot_filename)
        plt.close()
        logger.info(f"Plot saved as {plot_filename}")
        return plot_filename
    except Exception as e:
        logger.error(f"Error generating plot: {e}")
        return None


# ----- End agents/visualizer.py -----

# ----- Begin app.py (Encoding: ascii) -----
# app.py

import uvicorn
from fastapi import FastAPI, UploadFile, File, Form
from fastapi.responses import FileResponse, JSONResponse
from utils.data_loader import load_csv
from utils.schema_extractor import extract_schema
from utils.summary_generator import generate_summary
from agents.query_generator import generate_pandas_query
from agents.response_generator import generate_final_response
from agents.visualizer import generate_matplotlib_code, save_plot
import os
import logging
from rich.console import Console

console = Console()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

DATA_DIR = "data"


@app.post("/upload_csv/")
async def upload_csv(file: UploadFile = File(...)):
    file_location = f"{DATA_DIR}/{file.filename}"
    with open(file_location, "wb+") as file_object:
        file_object.write(await file.read())
    logger.info(f"File '{file.filename}' saved at '{file_location}'")
    return {"info": f"file '{file.filename}' saved at '{file_location}'"}


@app.post("/ask_question/")
async def ask_question(question: str = Form(...), filename: str = Form(...)):
    
    logger.info(f"Received question: '{question}' for file: '{filename}'")
    # Load Data
    df = load_csv(f"{DATA_DIR}/{filename}")
    _vars = {}
    _vars["df"] = df
    _vars['query_result'] = None
    # Extract Schema
    schema = extract_schema(df)

    # Generate Summary
    summary = generate_summary(df)

    # Generate Pandas Query
    pandas_query = generate_pandas_query(question, schema)

    if not pandas_query:
        logger.error("Failed to generate a valid pandas query.")
        return JSONResponse(
            content={"error": "Failed to generate a valid pandas query."},
            status_code=400,
        )

    # Execute Query
    try:
        exec(pandas_query, _vars)
        query_result = _vars['query_result']
        console.log(query_result)
        logger.info("Successfully executed pandas query.")
    except Exception as e:
        logger.error(f"Failed to execute query: {e}")
        return JSONResponse(
            content={"error": f"Failed to execute query: {e}"},
            status_code=400,
        )

    # Generate Final Response
    final_response = generate_final_response(question, query_result, summary)

    logger.info(f"Generated response: {final_response}")

    return {"response": final_response}


@app.post("/visualize/")
async def visualize(question: str = Form(...), filename: str = Form(...)):
    logger.info(f"Received visualization request: '{question}' for file: '{filename}'")
    # Load Data
    df = load_csv(f"{DATA_DIR}/{filename}")

    # Extract Schema
    schema = extract_schema(df)

    # Generate Matplotlib Code
    matplotlib_code = generate_matplotlib_code(question, schema)

    if not matplotlib_code:
        logger.error("Failed to generate matplotlib code.")
        return JSONResponse(
            content={"error": "Failed to generate matplotlib code."},
            status_code=400,
        )

    # Save Plot
    plot_filename = save_plot(matplotlib_code, df)

    if not plot_filename:
        logger.error("Failed to generate the plot.")
        return JSONResponse(
            content={"error": "Failed to generate the plot."},
            status_code=400,
        )

    logger.info(f"Generated plot saved as: {plot_filename}")

    return FileResponse(plot_filename, media_type="image/png")


if __name__ == "__main__":
    if not os.path.exists(DATA_DIR):
        os.makedirs(DATA_DIR)
    uvicorn.run(app, host="0.0.0.0", port=8000)


# ----- End app.py -----

# ----- Begin utils/data_loader.py (Encoding: ascii) -----
# utils/data_loader.py

import pandas as pd
import logging
from rich.console import Console

console = Console()
logger = logging.getLogger(__name__)

def load_csv(filepath):
    logger.info(f"Loading CSV file from '{filepath}'")
    try:
        df = pd.read_csv(filepath)
        logger.info(f"Loaded dataframe with shape {df.shape}")
        return df
    except Exception as e:
        logger.error(f"Error loading CSV file: {e}")
        return None


# ----- End utils/data_loader.py -----

# ----- Begin utils/schema_extractor.py (Encoding: ascii) -----
# utils/schema_extractor.py

import logging
from rich.console import Console

console = Console()
logger = logging.getLogger(__name__)

def extract_schema(df):
    logger.info("Extracting schema from dataframe.")
    schema = ""
    for column in df.columns:
        dtype = df[column].dtype
        schema += f"Column: {column}, Type: {dtype}\n"
    schema = schema.strip()
    logger.debug(f"Extracted schema: {schema}")
    return schema


# ----- End utils/schema_extractor.py -----

# ----- Begin utils/summary_generator.py (Encoding: ascii) -----
# utils/summary_generator.py

import logging
from rich.console import Console

console = Console()
logger = logging.getLogger(__name__)

def generate_summary(df):
    logger.info("Generating summary of dataframe.")
    summary = df.describe(include='all').to_string()
    logger.debug(f"Generated summary: {summary}")
    return summary


# ----- End utils/summary_generator.py -----

